#!/usr/bin/env ruby

# frozen_string_literal: true

require "date"
require "fileutils"
require "active_support/core_ext/string/inflections"
require "phlex"
require "redcarpet"
require "rouge"
require "rouge/plugins/redcarpet"

module PageComponents
  class Layout < Phlex::View
    def initialize(title)
      @title_text = title
    end

    def template(&block)
      doctype

      html do
        head do
          meta charset: "utf-8"
          meta name: "viewport", content: "width=device-width, initial-scale=1"
          link rel: "preload", href: "/static/roboto_slab_regular.ttf", as: "font", crossorigin: true
          link rel: "preload", href: "/static/fira_code_regular.ttf", as: "font", crossorigin: true
          link rel: "stylesheet", href: "/static/main.css"
          title "#{title_text} | jai.moe"
        end

        body do
          nav do
            div class: "nav-items" do
              a(href: "/") { "jai.moe" }
              a(href: "https://twitter.com/jai_1337") { "twitter" }
              a(href: "https://github.com/jai-x") { "github" }
              a(href: "mailto:jai@jai.moe") { "email" }
              a(href: "https://github.com/jai-x/jai-x.github.io") { "source" }
            end
            div class: "nav-line"
          end

          main { yield_content(&block) }
        end
      end
    end

    private

    attr_reader :title_text, :content_view
  end

  class MarkdownCodeBlock < Phlex::View
    def initialize(parsed, lang, filename)
      @parsed = parsed
      @lang = lang
      @filename = filename
    end

    def template
      div class: "code-block" do
        div(class: "code-label")  { label }
        pre do
          code class: "code-highlight" do
            raw parsed
          end
        end
      end
    end

    private

    attr_reader :parsed, :lang, :filename

    def label
      filename.present? ? filename : "#{lang.capitalize} code"
    end
  end

  class Markdown < Phlex::View
    def initialize(content)
      @content = content
    end

    def template
      raw markdown.render(content)
    end

    private

    attr_reader :content

    def markdown
      Redcarpet::Markdown.new(renderer, {
        tables: true,
        fenced_code_blocks: true,
        footnotes: true,
      })
    end

    def renderer
      # absolute memes to avoid making new classes
      @@renderer ||= Class.new(Redcarpet::Render::HTML) do
        include Rouge::Plugins::Redcarpet

        def block_code(code, lang)
          lang, filename = lang.split(":")
          parsed = super(code, lang)
          MarkdownCodeBlock.new(parsed, lang, filename).call
        end

        def rouge_formatter(_lexer)
          Rouge::Formatters::HTML.new
        end
      end
    end
  end

  class HomeSection < Phlex::View
    def template(&block)
      section class: "home-section" do
        yield_content(&block)
      end
    end
  end

  class Ideas < Phlex::View
    EMOJIS = [
      NOT_DONE    = "📝",
      IN_PROGRESS = "🚧",
      DONE        = "✅",
      UNKNOWN     = "❓",
    ].freeze

    def template
      p do
        ideas.each do |(status, line)|
          div(class: "idea-row") do
            span(class: "idea-emoji") { status }
            span line
          end
        end
      end
    end

    private

    def ideas
      @ideas ||= File.readlines("./ideas.md").map do |line|
        line.strip!

        next [NOT_DONE, line] if line.delete_prefix!("- [ ] ")
        next [IN_PROGRESS, line] if line.delete_prefix!("- [~] ")
        next [DONE, line] if line.delete_prefix!("- [x] ")

        [UNKNOWN, line]
      end
    end
  end

  class Projects < Phlex::View
    def template
      render Markdown.new(projects)
    end

    private

    def projects
      @projects ||= File.read("./projects.md")
    end
  end
end

class ApplicationPage < Phlex::View
  include PageComponents

  def path
    raise NotImplementedError
  end

  private

  def hr
    raw "<hr align=\"left\">"
  end
end

class PostPage < ApplicationPage
  def initialize(post)
    @post = post
  end

  def path
    "posts/#{post.slug}.html"
  end

  def template
    render Layout.new(post.title) do
      render Markdown.new(post.markdown)
    end
  end

  private

  attr_reader :post
end

class NotFoundPage < ApplicationPage
  def path
    "404.html"
  end

  def template
    render Layout.new("404") do
      h1 "404"
      p "Page not found"
    end
  end
end

class HomePage < ApplicationPage
  def initialize(posts)
    @posts = posts
  end

  def path
    "index.html"
  end

  def template
    render Layout.new("home") do
      render HomeSection.new do
        h2 "posts"
        posts.each do |post|
          h3 { a post.title, href: "/posts/#{post.slug}.html" }
          p { strong post.date }
        end
      end

      hr

      render HomeSection.new do
        h2 "projects"
        render Projects.new
      end

      hr

      render HomeSection.new do
        h2 "ideas"
        render Ideas.new
      end
    end
  end

  private

  attr_reader :posts

  def ideas
    @ideas ||= File.read("./ideas.md")
  end
end

class Post
  attr_reader :markdown

  def initialize(md_path)
    @markdown = File.read(md_path)
  end

  def title
    @title ||= begin
      title = markdown.lines[0].gsub("#", "").strip.downcase
      draft? ? "[DRAFT] #{title}" : title
    end
  end

  def date
    @date ||= Date.parse(markdown.lines[1].gsub("*", "").strip)
  end

  def draft?
    @draft ||= markdown.lines[2].strip == 'draft'
  end

  def slug
    @slug ||= title.parameterize
  end

  # Sort comparison by date
  def <=>(other)
    date <=> other.date
  end
end

class PageWriter
  def initialize(prefix: "./")
    @prefix = prefix
  end

  def write(view)
    path = File.join(prefix, view.path)

    File.open(path, "w") do |file|
      file.write(view.call)
      puts "Rendered page: #{path}"
    end
  end

  def delete(view)
    path = File.join(prefix, view.path)

    FileUtils.rm(path)
    puts "Deleted page: #{path}"
  rescue => e
    puts e
  end

  private

  attr_reader :prefix
end

class Website
  def generate(with_drafts: false)
    posts = with_drafts ? all_posts : all_posts.reject { |post| post.draft? }

    make_pages(posts).each { |page| writer.write page }
  end

  def clean
    make_pages(all_posts).each { |page| writer.delete page }
  end

  private

  def make_pages(posts)
    [
      NotFoundPage.new,
      HomePage.new(posts),
      *posts.map { |post| PostPage.new(post) },
    ].freeze
  end

  def all_posts
    @all_posts ||= Dir["./posts/*.md"]
      .map { |src| Post.new(src) }
      .sort
      .reverse
  end

  def writer
    @writer ||= PageWriter.new(prefix: "./www")
  end
end

website = Website.new

case ARGV.first&.strip
when "--with-drafts"
  website.generate(with_drafts: true)
when "--clean"
  website.clean
else
  website.generate
end
